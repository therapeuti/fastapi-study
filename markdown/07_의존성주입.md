# 07. 의존성 주입 (Dependency Injection)

의존성 주입은 FastAPI의 가장 강력한 기능 중 하나입니다. 이 장에서는 의존성 주입의 개념과 실용적인 사용법을 배웁니다.

## 1. 의존성 주입의 개념

### 1.1 의존성 주입이란?

의존성 주입(DI)은 함수가 필요로 하는 데이터나 리소스를 외부에서 주입받는 패턴입니다.

**장점:**
- 코드 재사용성 향상
- 테스트 용이 (Mock 주입 가능)
- 코드 간결화
- 유지보수 용이

### 1.2 문제가 있는 코드

```python
# ❌ 의존성 주입 없는 코드
from fastapi import FastAPI

app = FastAPI()

def get_query_param():
    # 함수 내부에서 외부 의존성 처리
    q = "default"
    skip = 0
    limit = 10
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items():
    params = get_query_param()
    return params
```

**문제:**
- 파라미터를 하드코딩함
- 재사용성 낮음
- 테스트하기 어려움

### 1.3 의존성 주입으로 개선

```python
# ✅ 의존성 주입 사용
from fastapi import FastAPI, Depends

app = FastAPI()

def common_parameters(q: str | None = None, skip: int = 0, limit: int = 10):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons
```

**장점:**
- 파라미터를 동적으로 처리
- 여러 엔드포인트에서 재사용 가능
- 테스트하기 쉬움

---

## 2. 기본 의존성

### 2.1 간단한 의존성

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def get_db():
    """
    데이터베이스 연결을 반환합니다.
    """
    return {"connection": "database"}

@app.get("/items/")
async def read_items(db: dict = Depends(get_db)):
    """
    의존성으로 받은 db를 사용합니다.
    """
    return {"db": db}
```

### 2.2 의존성 체인

한 의존성이 다른 의존성을 사용할 수 있습니다.

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def get_db():
    """
    데이터베이스 연결을 반환합니다.
    """
    return {"connection": "database"}

def get_user(db: dict = Depends(get_db)):
    """
    db 의존성을 사용하여 사용자를 가져옵니다.
    """
    return {
        "username": "john",
        "email": "john@example.com",
        "db": db
    }

@app.get("/users/")
async def read_user(user: dict = Depends(get_user)):
    """
    user 의존성을 사용합니다.
    """
    return user
```

**의존성 그래프:**
```
read_user (엔드포인트)
  └── get_user (의존성)
      └── get_db (의존성)
```

---

## 3. 쿼리 파라미터 의존성

### 3.1 공통 파라미터 추출

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def common_parameters(
    q: str | None = None,
    skip: int = 0,
    limit: int = 10
):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons

@app.get("/users/")
async def read_users(commons: dict = Depends(common_parameters)):
    return commons

# 두 엔드포인트가 동일한 파라미터를 공유합니다.
```

**요청:**
```
GET http://localhost:8000/items?q=foo&skip=5&limit=20
응답: {"q": "foo", "skip": 5, "limit": 20}
```

### 3.2 클래스를 사용한 의존성

```python
from fastapi import FastAPI, Depends

app = FastAPI()

class CommonParameters:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 10):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: CommonParameters = Depends()):
    """
    클래스를 의존성으로 사용합니다.
    """
    return {
        "q": commons.q,
        "skip": commons.skip,
        "limit": commons.limit
    }
```

---

## 4. 실제 사용 예제

### 예제 1: 데이터베이스 연결

```python
from fastapi import FastAPI, Depends

app = FastAPI()

class Database:
    def __init__(self):
        self.connected = False

    def connect(self):
        self.connected = True
        return "Connected to database"

    def disconnect(self):
        self.connected = False

db = Database()

def get_db():
    """
    데이터베이스 인스턴스를 반환합니다.
    """
    return db

@app.get("/items/")
async def get_items(database: Database = Depends(get_db)):
    """
    데이터베이스 의존성을 사용합니다.
    """
    if database.connected:
        return {"items": [1, 2, 3]}
    return {"error": "Database not connected"}

# 테스트
@app.on_event("startup")
async def startup():
    db.connect()

@app.on_event("shutdown")
async def shutdown():
    db.disconnect()
```

### 예제 2: 인증

```python
from fastapi import FastAPI, Depends, HTTPException, status
from typing import Optional

app = FastAPI()

def verify_token(token: str | None = None) -> dict:
    """
    토큰을 검증합니다.
    """
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token required"
        )

    if token != "valid_token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

    return {"token": token, "user": "john"}

@app.get("/protected")
async def protected_route(current_user: dict = Depends(verify_token)):
    """
    토큰 검증이 필요한 엔드포인트입니다.
    """
    return {"message": f"Hello {current_user['user']}"}
```

**테스트:**
```bash
# 토큰 없음
curl http://localhost:8000/protected
# 응답: 401 Unauthorized

# 유효한 토큰
curl http://localhost:8000/protected?token=valid_token
# 응답: {"message": "Hello john"}

# 무효한 토큰
curl http://localhost:8000/protected?token=invalid
# 응답: 401 Unauthorized
```

### 예제 3: 권한 검사

```python
from fastapi import FastAPI, Depends, HTTPException, status

app = FastAPI()

def get_current_user(token: str | None = None) -> dict:
    """
    현재 사용자를 반환합니다.
    """
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token required"
        )
    return {"user_id": 1, "username": "john", "role": "admin"}

def require_admin(current_user: dict = Depends(get_current_user)) -> dict:
    """
    관리자 권한을 요구합니다.
    """
    if current_user["role"] != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user

@app.get("/admin/users/")
async def get_all_users(admin: dict = Depends(require_admin)):
    """
    관리자만 접근 가능한 엔드포인트입니다.
    """
    return {
        "message": "All users",
        "admin": admin["username"]
    }
```

### 예제 4: 페이지네이션 의존성

```python
from fastapi import FastAPI, Depends, Query
from typing import List

app = FastAPI()

class PaginationParams:
    def __init__(
        self,
        skip: int = Query(0, ge=0),
        limit: int = Query(10, ge=1, le=100)
    ):
        self.skip = skip
        self.limit = limit

items_db = [
    {"id": i, "name": f"Item {i}"}
    for i in range(1, 101)
]

@app.get("/items/")
async def list_items(pagination: PaginationParams = Depends()):
    """
    페이지네이션을 적용하여 항목을 반환합니다.
    """
    items = items_db[pagination.skip : pagination.skip + pagination.limit]
    return {
        "items": items,
        "total": len(items_db),
        "skip": pagination.skip,
        "limit": pagination.limit
    }
```

**테스트:**
```
GET http://localhost:8000/items?skip=10&limit=5
응답:
{
  "items": [
    {"id": 11, "name": "Item 11"},
    ...
  ],
  "total": 100,
  "skip": 10,
  "limit": 5
}
```

---

## 5. 선택적 의존성

### 5.1 기본값이 있는 의존성

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def optional_dependency(param: str | None = None):
    return {"param": param}

@app.get("/items/")
async def read_items(dep: dict = Depends(optional_dependency)):
    """
    의존성이 선택적입니다.
    """
    return dep

# GET http://localhost:8000/items
# 응답: {"param": null}

# GET http://localhost:8000/items?param=foo
# 응답: {"param": "foo"}
```

---

## 6. 의존성 주입 활용

### 6.1 캐싱으로 성능 향상

```python
from fastapi import FastAPI, Depends
import time

app = FastAPI()

def expensive_operation():
    """
    시간이 오래 걸리는 작업입니다.
    FastAPI는 자동으로 이 함수를 캐시합니다.
    """
    print("Executing expensive operation...")
    time.sleep(1)
    return {"result": "expensive"}

@app.get("/expensive/")
async def get_expensive(result: dict = Depends(expensive_operation)):
    """
    같은 요청에서는 expensive_operation이 한 번만 실행됩니다.
    """
    return result
```

### 6.2 복잡한 의존성 체인

```python
from fastapi import FastAPI, Depends, HTTPException, status

app = FastAPI()

def get_token(token: str | None = None) -> str:
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token required"
        )
    return token

def get_current_user(token: str = Depends(get_token)) -> dict:
    """
    토큰으로부터 사용자를 조회합니다.
    """
    users = {
        "token123": {"id": 1, "name": "Alice"},
        "token456": {"id": 2, "name": "Bob"}
    }
    if token not in users:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
    return users[token]

def get_user_permissions(
    current_user: dict = Depends(get_current_user)
) -> dict:
    """
    사용자 권한을 반환합니다.
    """
    permissions = {
        1: ["read", "write", "delete"],
        2: ["read", "write"]
    }
    return {
        "user_id": current_user["id"],
        "permissions": permissions.get(current_user["id"], [])
    }

@app.get("/secure-data/")
async def get_secure_data(perms: dict = Depends(get_user_permissions)):
    """
    의존성 체인: get_token -> get_current_user -> get_user_permissions
    """
    return {
        "message": "Secure data",
        "user_id": perms["user_id"],
        "permissions": perms["permissions"]
    }
```

---

## 7. 전역 의존성

### 7.1 모든 엔드포인트에 의존성 적용

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def verify_request(x_token: str):
    """
    모든 요청을 검증합니다.
    """
    if x_token != "secret":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid X-Token"
        )
    return x_token

# 전역 의존성 설정
app = FastAPI(dependencies=[Depends(verify_request)])

@app.get("/items/")
async def read_items():
    """
    이 엔드포인트는 전역 의존성을 자동으로 적용받습니다.
    """
    return {"items": []}

# GET http://localhost:8000/items?x_token=secret
# 응답: {"items": []}

# GET http://localhost:8000/items?x_token=wrong
# 응답: 400 Bad Request
```

### 7.2 라우터에 의존성 적용

```python
from fastapi import FastAPI, APIRouter, Depends

app = FastAPI()

def verify_user():
    return {"user": "john"}

router = APIRouter(dependencies=[Depends(verify_user)])

@router.get("/items/")
async def read_items():
    return {"items": []}

app.include_router(router, prefix="/api")
```

---

## 8. 테스트

### 8.1 의존성 Mock하기

```python
from fastapi import FastAPI, Depends
from fastapi.testclient import TestClient

app = FastAPI()

def get_db():
    return {"database": "real"}

@app.get("/items/")
async def read_items(db: dict = Depends(get_db)):
    return {"items": [], "db": db}

# 테스트 - 실제 의존성 사용
client = TestClient(app)
response = client.get("/items/")
assert response.status_code == 200

# 테스트 - Mock 의존성 사용
def mock_db():
    return {"database": "test"}

app.dependency_overrides[get_db] = mock_db

response = client.get("/items/")
assert response.json()["db"]["database"] == "test"

# 기존 의존성 복원
app.dependency_overrides.clear()
```

---

## 9. 실전 예제: 완전한 사용자 API

```python
from fastapi import FastAPI, Depends, HTTPException, status, Header
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

app = FastAPI(title="사용자 관리 API")

# 데이터 모델
class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str

# 데이터베이스 시뮬레이션
users_db = {
    1: {"id": 1, "username": "alice", "email": "alice@example.com", "password_hash": "hash1"},
    2: {"id": 2, "username": "bob", "email": "bob@example.com", "password_hash": "hash2"}
}

# 의존성들
def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    토큰을 검증합니다.
    """
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization header required"
        )

    token = authorization.replace("Bearer ", "")

    if token != "valid_token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

    return {"user_id": 1, "token": token}

def get_current_user(auth: dict = Depends(verify_token)) -> dict:
    """
    현재 사용자를 반환합니다.
    """
    user_id = auth["user_id"]
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return users_db[user_id]

# 엔드포인트
@app.get("/users/me", response_model=UserResponse)
async def get_current_user_info(current_user: dict = Depends(get_current_user)):
    """
    현재 사용자 정보를 반환합니다.
    """
    return current_user

@app.post("/users/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    """
    새로운 사용자를 생성합니다.
    """
    new_user = {
        "id": max(users_db.keys()) + 1,
        "username": user.username,
        "email": user.email,
        "password_hash": "hashed"
    }
    users_db[new_user["id"]] = new_user
    return new_user

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int, current_user: dict = Depends(get_current_user)):
    """
    특정 사용자를 조회합니다. (인증 필요)
    """
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return users_db[user_id]
```

---

## 요약

### 의존성 주입의 핵심
- `Depends()` 함수로 의존성 명시
- 의존성 함수들을 재사용 가능하게 작성
- 의존성 체인으로 복잡한 로직 구성
- 테스트하기 쉬운 구조

### 주요 이점
- 코드 재사용성 향상
- 테스트 용이
- 코드 간결화
- 유지보수 용이
- 자동 캐싱

### 실제 사용 사례
- 인증/인가
- 데이터베이스 연결
- 로깅
- 페이지네이션
- 데이터 검증

**다음 장**: 미들웨어와 CORS에 대해 배웁니다.
