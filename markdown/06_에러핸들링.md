# 06. 에러 핸들링

적절한 에러 처리는 안정적인 API를 만드는 핵심입니다. 이 장에서는 FastAPI의 에러 핸들링 방법을 배웁니다.

## 1. HTTPException 기초

### 1.1 HTTPException이란?

`HTTPException`은 HTTP 에러를 나타내는 FastAPI의 예외 클래스입니다.

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    """
    HTTPException을 발생시킵니다.
    """
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Item ID must be greater than 0"
        )
    return {"item_id": item_id}
```

**요청:**
```
GET http://localhost:8000/items/0
```

**응답 (422 또는 400):**
```json
{"detail": "Item ID must be greater than 0"}
```

### 1.2 HTTPException 파라미터

```python
from fastapi import HTTPException, status

raise HTTPException(
    status_code=status.HTTP_404_NOT_FOUND,    # HTTP 상태 코드
    detail="Item not found",                   # 에러 메시지
    headers={"X-Error": "Custom header"}       # 응답 헤더 (선택사항)
)
```

---

## 2. 일반적인 에러 상황

### 2.1 404 Not Found

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

items_db = {
    1: {"id": 1, "name": "Laptop"},
    2: {"id": 2, "name": "Mouse"}
}

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    """
    리소스를 찾을 수 없을 때 404 반환.
    """
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found"
        )
    return items_db[item_id]
```

### 2.2 400 Bad Request

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

@app.post("/items/")
async def create_item(price: float):
    """
    잘못된 입력 데이터에 대해 400 반환.
    """
    if price < 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Price cannot be negative"
        )
    return {"price": price}
```

### 2.3 401 Unauthorized

```python
from fastapi import FastAPI, HTTPException, status, Header
from typing import Optional

app = FastAPI()

@app.get("/protected")
async def protected_route(authorization: Optional[str] = Header(None)):
    """
    인증이 필요한 엔드포인트.
    """
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"}
        )
    return {"message": "Authenticated"}
```

### 2.4 403 Forbidden

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

@app.get("/admin")
async def admin_panel(is_admin: bool = False):
    """
    권한이 필요한 엔드포인트.
    """
    if not is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not have permission to access this resource"
        )
    return {"message": "Welcome to admin panel"}
```

### 2.5 409 Conflict

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

users_db = {"john": {"id": 1, "username": "john"}}

@app.post("/users/")
async def create_user(username: str):
    """
    이미 존재하는 리소스를 생성할 때 409 반환.
    """
    if username in users_db:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"User {username} already exists"
        )
    return {"username": username}
```

### 2.6 422 Unprocessable Entity

```python
from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float

app = FastAPI()

@app.post("/items/")
async def create_item(item: Item):
    """
    Pydantic 검증 실패 시 자동으로 422 반환.
    """
    return item

# 요청:
# {
#   "name": "Laptop",
#   "price": "invalid"  # 문자열이 아닌 숫자여야 함
# }
# 응답: 422 Unprocessable Entity
```

### 2.7 500 Internal Server Error

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

@app.get("/error")
async def trigger_error():
    """
    예상치 못한 에러 발생.
    """
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail="Internal server error"
    )
```

---

## 3. 커스텀 에러 처리

### 3.1 에러 핸들러 작성

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

# 커스텀 예외 클래스
class ItemNotFoundError(Exception):
    def __init__(self, item_id: int):
        self.item_id = item_id

# 에러 핸들러 등록
@app.exception_handler(ItemNotFoundError)
async def item_not_found_handler(request: Request, exc: ItemNotFoundError):
    return JSONResponse(
        status_code=404,
        content={
            "error": "Item not found",
            "item_id": exc.item_id
        }
    )

# 사용
items_db = {1: {"id": 1, "name": "Laptop"}}

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    if item_id not in items_db:
        raise ItemNotFoundError(item_id)
    return items_db[item_id]
```

### 3.2 여러 예외 처리

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

class ValidationError(Exception):
    def __init__(self, message: str):
        self.message = message

class DatabaseError(Exception):
    def __init__(self, message: str):
        self.message = message

@app.exception_handler(ValidationError)
async def validation_error_handler(request: Request, exc: ValidationError):
    return JSONResponse(
        status_code=400,
        content={"error": exc.message}
    )

@app.exception_handler(DatabaseError)
async def database_error_handler(request: Request, exc: DatabaseError):
    return JSONResponse(
        status_code=500,
        content={"error": "Database error: " + exc.message}
    )

@app.post("/items/")
async def create_item(name: str, price: float):
    if price < 0:
        raise ValidationError("Price cannot be negative")

    try:
        # DB 작업 시뮬레이션
        if price > 10000:
            raise Exception("DB connection failed")
    except Exception as e:
        raise DatabaseError(str(e))

    return {"name": name, "price": price}
```

---

## 4. Pydantic 검증 에러 처리

### 4.1 기본 검증 에러

```python
from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float

app = FastAPI()

@app.post("/items/")
async def create_item(item: Item):
    return item

# 요청 (가격이 문자열)
# {
#   "name": "Laptop",
#   "price": "1500"  # 숫자여야 함
# }

# 응답: 422 Unprocessable Entity
# {
#   "detail": [
#     {
#       "type": "float_parsing",
#       "loc": ["body", "price"],
#       "msg": "Input should be a valid number",
#       "input": "1500"
#     }
#   ]
# }
```

### 4.2 커스텀 Pydantic 에러 핸들러

```python
from fastapi import FastAPI, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: float

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    """
    Pydantic 검증 에러를 처리합니다.
    """
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "detail": "Validation error",
            "errors": exc.errors()
        }
    )

@app.post("/items/")
async def create_item(item: Item):
    return item
```

---

## 5. 실제 예제

### 예제 1: 상품 조회 API

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel

app = FastAPI(title="상품 조회 API")

class Item(BaseModel):
    id: int
    name: str
    price: float
    stock: int

items_db = [
    {"id": 1, "name": "Laptop", "price": 1500, "stock": 5},
    {"id": 2, "name": "Mouse", "price": 50, "stock": 0},
    {"id": 3, "name": "Keyboard", "price": 100, "stock": 3},
]

@app.get("/items/{item_id}", response_model=Item)
async def get_item(item_id: int):
    """
    특정 상품을 조회합니다.
    """
    # ID 검증
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Item ID must be positive"
        )

    # 상품 찾기
    for item in items_db:
        if item["id"] == item_id:
            return item

    # 상품이 없으면 404
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Item with id {item_id} not found"
    )

@app.post("/items/{item_id}/purchase")
async def purchase_item(item_id: int, quantity: int):
    """
    상품을 구매합니다.
    """
    # 상품 찾기
    item = None
    for i in items_db:
        if i["id"] == item_id:
            item = i
            break

    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )

    # 수량 검증
    if quantity < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Quantity must be at least 1"
        )

    # 재고 확인
    if item["stock"] < quantity:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Insufficient stock. Available: {item['stock']}, Requested: {quantity}"
        )

    # 구매 처리
    item["stock"] -= quantity

    return {
        "message": "Purchase successful",
        "item_name": item["name"],
        "quantity": quantity,
        "remaining_stock": item["stock"]
    }
```

### 예제 2: 사용자 인증 API

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr

app = FastAPI(title="사용자 인증 API")

class User(BaseModel):
    username: str
    email: str
    password: str

users_db = {
    "john": {
        "username": "john",
        "email": "john@example.com",
        "password_hash": "hashed_password"
    }
}

@app.post("/register")
async def register(user: User):
    """
    새로운 사용자를 등록합니다.
    """
    # 사용자명 검증
    if len(user.username) < 3:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username must be at least 3 characters"
        )

    # 비밀번호 검증
    if len(user.password) < 8:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password must be at least 8 characters"
        )

    # 중복 검사
    if user.username in users_db:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Username already exists"
        )

    # 사용자 등록
    users_db[user.username] = {
        "username": user.username,
        "email": user.email,
        "password_hash": "hashed_password"  # 실제로는 해싱 필요
    }

    return {
        "message": "User registered successfully",
        "username": user.username,
        "email": user.email
    }

@app.post("/login")
async def login(username: str, password: str):
    """
    사용자를 로그인합니다.
    """
    # 사용자 찾기
    if username not in users_db:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    user = users_db[username]

    # 비밀번호 검증
    if user["password_hash"] != "hashed_password":  # 실제로는 bcrypt 사용
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    return {
        "message": "Login successful",
        "username": username,
        "email": user["email"]
    }

@app.delete("/users/{username}")
async def delete_user(username: str, admin_token: str = None):
    """
    사용자를 삭제합니다.
    """
    # 권한 확인
    if not admin_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Admin token required"
        )

    if admin_token != "admin_secret":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid admin token"
        )

    # 사용자 찾기
    if username not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # 사용자 삭제
    del users_db[username]

    return {
        "message": "User deleted successfully",
        "username": username
    }
```

---

## 6. 에러 응답 표준화

### 6.1 일관된 에러 응답

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class ErrorResponse(BaseModel):
    success: bool = False
    error_code: str
    message: str
    details: Optional[dict] = None

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return {
        "success": False,
        "error_code": "HTTP_ERROR",
        "message": exc.detail,
        "status_code": exc.status_code
    }

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid item ID"
        )
    return {"item_id": item_id}
```

### 6.2 로깅과 함께 에러 처리

```python
from fastapi import FastAPI, HTTPException, status
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

app = FastAPI()

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    # 에러 로깅
    logger.error(
        f"[{datetime.now()}] HTTP Exception: "
        f"status={exc.status_code}, detail={exc.detail}, path={request.url.path}"
    )

    return {
        "error": exc.detail,
        "status_code": exc.status_code
    }

@app.get("/items/{item_id}")
async def get_item(item_id: int):
    if item_id < 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid item ID"
        )
    return {"item_id": item_id}
```

---

## 요약

### HTTPException 사용
- `status_code`: HTTP 상태 코드
- `detail`: 에러 메시지
- `headers`: 응답 헤더 (선택사항)

### 주요 에러 상황
- `400 Bad Request`: 클라이언트 입력 오류
- `401 Unauthorized`: 인증 필요
- `403 Forbidden`: 권한 없음
- `404 Not Found`: 리소스 없음
- `409 Conflict`: 리소스 충돌
- `422 Unprocessable Entity`: 검증 실패
- `500 Internal Server Error`: 서버 오류

### 모범 사례
- 명확한 에러 메시지 제공
- 일관된 에러 응답 형식
- 적절한 HTTP 상태 코드 사용
- 에러 로깅
- 커스텀 예외 클래스 정의

**다음 장**: 의존성 주입(Dependency Injection)에 대해 배웁니다.
