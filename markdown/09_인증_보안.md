# 09. 인증과 보안

FastAPI는 보안 기능을 내장하고 있습니다. 이 장에서는 인증과 보안 구현 방법을 배웁니다.

## 1. 기본 인증 (Basic Authentication)

### 1.1 개념

Basic Authentication은 username과 password를 Base64로 인코딩하여 HTTP 헤더로 전송합니다.

```
Authorization: Basic base64(username:password)
```

### 1.2 구현

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import base64

app = FastAPI()
security = HTTPBasic()

# 사용자 정보 (실제로는 데이터베이스에서 조회)
users = {
    "john": "secret_password",
    "alice": "another_password"
}

@app.get("/secure/")
async def secure_endpoint(credentials: HTTPBasicCredentials = Depends(security)):
    """
    Basic Authentication이 필요한 엔드포인트입니다.
    """
    # 사용자명 확인
    if credentials.username not in users:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username",
            headers={"WWW-Authenticate": "Basic"}
        )

    # 비밀번호 확인
    if users[credentials.username] != credentials.password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid password",
            headers={"WWW-Authenticate": "Basic"}
        )

    return {"message": f"Hello {credentials.username}"}
```

**테스트:**
```bash
# curl 사용
curl -u john:secret_password http://localhost:8000/secure/

# 또는 Authorization 헤더
curl -H "Authorization: Basic am9objpzZWNyZXRfcGFzc3dvcmQ=" http://localhost:8000/secure/
```

---

## 2. Bearer Token 인증

### 2.1 개념

Bearer Token은 OAuth 2.0 표준의 일부이며, 특정 형식의 토큰을 사용합니다.

```
Authorization: Bearer <token>
```

### 2.2 구현

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

app = FastAPI()
security = HTTPBearer()

# 유효한 토큰
VALID_TOKENS = ["token123", "token456"]

@app.get("/protected/")
async def protected_endpoint(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Bearer Token이 필요한 엔드포인트입니다.
    """
    token = credentials.credentials

    if token not in VALID_TOKENS:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

    return {"message": "Access granted"}
```

**테스트:**
```bash
curl -H "Authorization: Bearer token123" http://localhost:8000/protected/
```

---

## 3. OAuth 2.0 with Password (JWT 방식)

### 3.1 필수 패키지 설치

```bash
pip install python-jose[cryptography] passlib[bcrypt] python-multipart
```

### 3.2 구현

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from datetime import datetime, timedelta, timezone
from jose import JWTError, jwt
from passlib.context import CryptContext

# 설정
SECRET_KEY = "your-secret-key-keep-this-safe"  # 실제로는 환경 변수에서
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# 비밀번호 해싱
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 설정
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# 데이터 모델
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str

# 사용자 데이터베이스 (실제로는 DB에서)
users_db = {
    "john": {
        "username": "john",
        "full_name": "John Doe",
        "email": "john@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lm",  # "secret"
        "disabled": False,
    }
}

# 유틸리티 함수
def verify_password(plain_password, hashed_password):
    """
    평문 비밀번호와 해시된 비밀번호를 비교합니다.
    """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    """
    비밀번호를 해시합니다.
    """
    return pwd_context.hash(password)

def get_user(username: str):
    """
    사용자를 조회합니다.
    """
    if username in users_db:
        user_dict = users_db[username]
        return UserInDB(**user_dict)

def authenticate_user(username: str, password: str):
    """
    사용자를 인증합니다.
    """
    user = get_user(username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    """
    JWT 토큰을 생성합니다.
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    """
    현재 사용자를 반환합니다.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception

    user = get_user(username=token_data.username)
    if user is None:
        raise credentials_exception

    return user

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
):
    """
    현재 활성 사용자를 반환합니다.
    """
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# FastAPI 앱
app = FastAPI()

@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    로그인하여 토큰을 얻습니다.
    """
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=User)
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    """
    현재 사용자의 정보를 반환합니다.
    """
    return current_user

@app.get("/items/")
async def read_items(current_user: User = Depends(get_current_active_user)):
    """
    보호된 엔드포인트입니다.
    """
    return [{"item_id": 1, "owner": current_user.username}]
```

**테스트:**
```bash
# 1. 로그인하여 토큰 획득
curl -X POST http://localhost:8000/token \
  -d "username=john&password=secret"

# 응답:
# {"access_token": "eyJhbGc...", "token_type": "bearer"}

# 2. 토큰으로 보호된 리소스 접근
curl -H "Authorization: Bearer <token>" http://localhost:8000/users/me
```

---

## 4. HTTPS와 보안 헤더

### 4.1 HTTPS 설정

```python
from fastapi import FastAPI
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app = FastAPI()

# HTTP를 HTTPS로 리다이렉트
app.add_middleware(HTTPSRedirectMiddleware)

# 신뢰할 수 있는 호스트만 허용
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["example.com", "www.example.com"]
)

@app.get("/")
async def read_root():
    return {"message": "Secure connection"}
```

### 4.2 보안 헤더 추가

```python
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

app = FastAPI()

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        """
        보안 헤더를 추가합니다.
        """
        response = await call_next(request)

        # XSS 방지
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"

        # CSRF 방지
        response.headers["Content-Security-Policy"] = "default-src 'self'"

        # Referrer 정책
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"

        return response

app.add_middleware(SecurityHeadersMiddleware)

@app.get("/")
async def read_root():
    return {"message": "Secure"}
```

---

## 5. 입력 검증 및 SQL Injection 방지

### 5.1 Pydantic으로 입력 검증

```python
from fastapi import FastAPI
from pydantic import BaseModel, Field, EmailStr
from typing import Optional

app = FastAPI()

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=20, regex="^[a-zA-Z0-9_]+$")
    email: EmailStr  # 이메일 형식 검증
    password: str = Field(..., min_length=8)

@app.post("/register/")
async def register(user: UserCreate):
    """
    입력 데이터가 자동으로 검증됩니다.
    """
    return {"message": f"User {user.username} registered"}

# ❌ 잘못된 입력은 422 Unprocessable Entity 반환
# {
#   "username": "ab",  # 너무 짧음
#   "email": "invalid",  # 이메일 형식 아님
#   "password": "short"  # 너무 짧음
# }
```

### 5.2 SQL 쿼리 안전화

```python
from fastapi import FastAPI
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

app = FastAPI()

# ❌ 위험: SQL Injection 가능
@app.get("/items_unsafe/")
async def get_items_unsafe(item_id: int):
    query = f"SELECT * FROM items WHERE id = {item_id}"
    # 이 코드는 SQL Injection에 취약합니다

# ✅ 안전: 파라미터 바인딩 사용
from sqlalchemy import text

@app.get("/items/")
async def get_items(item_id: int):
    # SQLAlchemy가 파라미터를 안전하게 처리합니다
    query = text("SELECT * FROM items WHERE id = :item_id")
    # result = db.execute(query, {"item_id": item_id})
```

---

## 6. Rate Limiting

### 6.1 요청 제한

```python
from fastapi import FastAPI, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from collections import defaultdict
from datetime import datetime, timedelta

app = FastAPI()

# 요청 저장소 (실제로는 Redis 등 사용)
request_counts = defaultdict(list)

class RateLimitMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        """
        IP당 요청 수를 제한합니다.
        """
        client_ip = request.client.host

        # 현재 시간
        now = datetime.now()

        # 1분 이내의 요청만 유지
        request_counts[client_ip] = [
            req_time for req_time in request_counts[client_ip]
            if now - req_time < timedelta(minutes=1)
        ]

        # 요청 수 확인 (1분에 10개 제한)
        if len(request_counts[client_ip]) >= 10:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Too many requests"
            )

        # 요청 기록
        request_counts[client_ip].append(now)

        response = await call_next(request)
        return response

app.add_middleware(RateLimitMiddleware)

@app.get("/items/")
async def read_items():
    return {"items": []}
```

---

## 7. 실전 예제: 완전한 사용자 인증 시스템

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, EmailStr
from datetime import datetime, timedelta, timezone
from jose import JWTError, jwt
from passlib.context import CryptContext

# 설정
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# 비밀번호 해싱
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

app = FastAPI(title="사용자 인증 시스템")

# 모델
class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

class UserInDB(User):
    hashed_password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class UserRegister(BaseModel):
    username: str
    email: EmailStr
    password: str
    full_name: str | None = None

# 데이터베이스 시뮬레이션
users_db = {}

# 유틸리티
def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    if username not in users_db:
        raise HTTPException(status_code=401, detail="User not found")

    user_dict = users_db[username]
    return User(**{k: v for k, v in user_dict.items() if k != "hashed_password"})

# 엔드포인트
@app.post("/register/", response_model=User)
async def register(user_data: UserRegister):
    """
    새로운 사용자를 등록합니다.
    """
    if user_data.username in users_db:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Username already exists"
        )

    hashed_password = hash_password(user_data.password)
    users_db[user_data.username] = {
        "username": user_data.username,
        "email": user_data.email,
        "full_name": user_data.full_name,
        "hashed_password": hashed_password,
        "disabled": False
    }

    return User(
        username=user_data.username,
        email=user_data.email,
        full_name=user_data.full_name
    )

@app.post("/login/", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    로그인하여 토큰을 획득합니다.
    """
    if form_data.username not in users_db:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    user = users_db[form_data.username]
    if not verify_password(form_data.password, user["hashed_password"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    access_token = create_access_token(
        data={"sub": form_data.username},
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/me/", response_model=User)
async def get_me(current_user: User = Depends(get_current_user)):
    """
    현재 사용자의 정보를 반환합니다.
    """
    return current_user

@app.get("/protected/")
async def protected_route(current_user: User = Depends(get_current_user)):
    """
    보호된 엔드포인트입니다.
    """
    return {"message": f"Hello {current_user.username}"}
```

---

## 요약

### 인증 방식
- **Basic Auth**: username:password Base64 인코딩
- **Bearer Token**: OAuth 2.0 표준
- **JWT**: JSON Web Token으로 상태 비저장 인증

### 보안 모범 사례
- HTTPS 사용
- 비밀번호 해싱 (bcrypt 권장)
- JWT로 상태 비저장 인증
- 입력 검증 (Pydantic 활용)
- SQL 쿼리 파라미터 바인딩
- 보안 헤더 추가
- Rate limiting 구현

### 필수 라이브러리
- `python-jose`: JWT 토큰
- `passlib`: 비밀번호 해싱
- `bcrypt`: 해싱 알고리즘
- `python-multipart`: Form 데이터

### 실전 팁
- 민감한 정보는 환경 변수에서 로드
- 토큰 만료 시간 설정
- CORS와 함께 보안 헤더 설정
- 데이터베이스에서 사용자 정보 조회
- 에러 메시지는 최소한으로

---

## 다음 단계

FastAPI 기본 학습을 완료했습니다! 다음 주제들을 학습하시길 추천합니다:

1. **데이터베이스 연동** (SQLAlchemy, Tortoise ORM)
2. **파일 업로드/다운로드**
3. **백그라운드 작업** (Celery)
4. **WebSocket**
5. **테스트** (pytest)
6. **배포** (Docker, AWS, Heroku)
7. **모니터링** (Sentry, ELK)
8. **API 문서화** (자동 생성된 docs 활용)

**축하합니다!** FastAPI의 핵심 개념을 모두 학습했습니다.
